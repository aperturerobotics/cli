{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to aperturerobotics/cli","text":"<p><code>aperturerobotics/cli</code> is a powerful fork of the popular <code>urfave/cli</code> v2 package, designed for building command-line applications in Go with a focus on simplicity and performance.</p> <p>Key differences from <code>urfave/cli</code>:</p> <ol> <li>Slim and Reflection-Free:<ul> <li>Removed <code>reflect</code> usage for smaller binaries and better performance.</li> <li>Tinygo compatible.</li> <li>Removed documentation generators.</li> <li>Removed altsrc package to focus on CLI handling only.</li> </ul> </li> <li>Stability: Try to maintain backward compatibility as much as possible.</li> </ol> <p>Documentation:</p> <ul> <li>Getting Started</li> <li>Examples</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Here's a simple example to get you started:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Name:  \"greet\",\n        Usage: \"say hello\",\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"name\",\n                Value:   \"world\",\n                Usage:   \"who to greet\",\n                EnvVars: []string{\"GREET_NAME\"},\n            },\n        },\n        Action: func(ctx *cli.Context) error {\n            name := ctx.String(\"name\")\n            fmt.Printf(\"Hello %s!\\n\", name)\n            return nil\n        },\n        Subcommands: []*cli.Command{\n            {\n                Name:  \"add\",\n                Usage: \"add a task to the list\",\n                Action: func(ctx *cli.Context) error {\n                    fmt.Println(\"added task: \", ctx.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:  \"complete\",\n                Usage: \"complete a task on the list\",\n                Action: func(ctx *cli.Context) error {\n                    fmt.Println(\"completed task: \", ctx.Args().First())\n                    return nil\n                },\n            },\n        },\n    }\n\n    if err := cmd.Run(os.Args); err != nil {\n        fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n        os.Exit(1)\n    }\n}\n</code></pre> <p>This example demonstrates basic command functionality, including automatic help text generation, flag parsing (with environment variable support), and subcommand routing. You can easily extend this foundation by adding more flags, subcommands, and complex actions. See the full getting started guide for more details.</p>"},{"location":"#supported-platforms","title":"Supported platforms","text":"<p>cli is tested against multiple versions of Go on Linux, and against the latest released version of Go on OS X and Windows. This project uses GitHub Actions for builds. To see our currently supported go versions and platforms, look at the github workflow configuration.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Getting started with <code>aperturerobotics/cli</code> is incredibly simple. A functional command-line application can be created with just a single line of code in your <code>main()</code> function.</p> <pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    (&amp;cli.App{}).Run(os.Args)\n}\n</code></pre> <p>While this app runs and displays basic help text, it doesn't perform any actions yet. Let's enhance it by adding a name, usage description, and an action to execute:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Name:  \"boom\",\n        Usage: \"make an explosive entrance\",\n        Action: func(*cli.Context) error {\n            fmt.Println(\"boom! I say!\")\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Running this improved version provides a more useful application with clear help text and a defined action.</p>","boost":2},{"location":"getting-started/#adding-flags","title":"Adding Flags","text":"<p>Let's make our application more interactive by adding a flag. Flags allow users to pass options to the command. We'll add a <code>--name</code> flag to specify who to greet.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Name:  \"boom\",\n        Usage: \"make an explosive entrance\",\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:  \"name\",\n                Value: \"world\", // Default value\n                Usage: \"who to greet\",\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            name := cCtx.String(\"name\")\n            fmt.Printf(\"boom! Hello %s!\\n\", name)\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Now you can run <code>go run main.go --name Bob</code> or simply <code>go run main.go</code> to use the default value \"world\". The help output (<code>go run main.go --help</code>) will also automatically include information about the new flag.</p>","boost":2},{"location":"getting-started/#adding-subcommands","title":"Adding Subcommands","text":"<p>For more complex applications, you might want different actions grouped under subcommands (like <code>git commit</code> or <code>docker ps</code>). Let's add a <code>greet</code> subcommand to our <code>boom</code> app.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Name:  \"boom\",\n        Usage: \"make an explosive entrance\",\n        Commands: []*cli.Command{\n            {\n                Name:  \"greet\",\n                Usage: \"say hello\",\n                Flags: []cli.Flag{\n                    &amp;cli.StringFlag{\n                        Name:  \"name\",\n                        Value: \"world\",\n                        Usage: \"who to greet\",\n                    },\n                },\n                Action: func(cCtx *cli.Context) error {\n                    name := cCtx.String(\"name\")\n                    fmt.Printf(\"Hello %s!\\n\", name)\n                    return nil\n                },\n            },\n            // Add more subcommands here\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Now, the main action is performed by running <code>go run main.go greet --name Dave</code>. Running <code>go run main.go --help</code> will show the available subcommands.</p> <p>This tutorial covers the basics of creating a CLI application, adding flags, and organizing functionality with subcommands using <code>aperturerobotics/cli</code>. Explore the Examples section for more advanced use cases.</p>","boost":2},{"location":"examples/arguments/","title":"Arguments","text":"<p>Accessing command-line arguments (values passed after the command and flags) is straightforward using the <code>Args</code> method on <code>cli.Context</code>. Here's an example:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Action: func(cCtx *cli.Context) error {\n            fmt.Printf(\"Hello %q\", cCtx.Args().Get(0))\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","boost":2},{"location":"examples/bash-completions/","title":"Bash Completions","text":"<p>You can enable built-in bash completion support by setting the <code>EnableBashCompletion</code> field on your <code>cli.App</code> to <code>true</code>. This automatically provides completion suggestions for your app's subcommands. You can also define custom completion logic for specific commands or flags.</p>","boost":2},{"location":"examples/bash-completions/#default-auto-completion","title":"Default auto-completion","text":"<p><pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        EnableBashCompletion: true,\n        Commands: []*cli.Command{\n            {\n                Name:    \"add\",\n                Aliases: []string{\"a\"},\n                Usage:   \"add a task to the list\",\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"added task: \", cCtx.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"completed task: \", cCtx.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"template\",\n                Aliases: []string{\"t\"},\n                Usage:   \"options for task templates\",\n                Subcommands: []*cli.Command{\n                    {\n                        Name:  \"add\",\n                        Usage: \"add a new template\",\n                        Action: func(cCtx *cli.Context) error {\n                            fmt.Println(\"new task template: \", cCtx.Args().First())\n                            return nil\n                        },\n                    },\n                    {\n                        Name:  \"remove\",\n                        Usage: \"remove an existing template\",\n                        Action: func(cCtx *cli.Context) error {\n                            fmt.Println(\"removed task template: \", cCtx.Args().First())\n                            return nil\n                        },\n                    },\n                },\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> </p>","boost":2},{"location":"examples/bash-completions/#custom-auto-completion","title":"Custom auto-completion","text":"<p><pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    tasks := []string{\"cook\", \"clean\", \"laundry\", \"eat\", \"sleep\", \"code\"}\n\n    app := &amp;cli.App{\n        EnableBashCompletion: true,\n        Commands: []*cli.Command{\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"completed task: \", cCtx.Args().First())\n                    return nil\n                },\n                BashComplete: func(cCtx *cli.Context) {\n                    // This will complete if no args are passed\n                    if cCtx.NArg() &gt; 0 {\n                        return\n                    }\n                    for _, t := range tasks {\n                        fmt.Println(t)\n                    }\n                },\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> </p>","boost":2},{"location":"examples/bash-completions/#enabling","title":"Enabling","text":"<p>To enable auto-completion for your application in the current shell session, you can use the <code>autocomplete/bash_autocomplete</code> script provided in the <code>aperturerobotics/cli</code> repository.</p> <p> The <code>bash-completion</code> package or equivalent that provides the <code>_get_comp_words_by_ref</code> function for the target platform must be installed and initialized for this completion script to work correctly.</p> <p>First, set the <code>PROG</code> environment variable to the name of your compiled application binary. Then, <code>source</code> the <code>autocomplete/bash_autocomplete</code> script:</p> <p>For example, if your cli program is called <code>myprogram</code>:</p> <pre><code>$ PROG=myprogram source path/to/cli/autocomplete/bash_autocomplete\n</code></pre> <p>Auto-completion is now enabled for the current shell, but will not persist into a new shell.</p>","boost":2},{"location":"examples/bash-completions/#distribution-and-persistent-autocompletion","title":"Distribution and Persistent Autocompletion","text":"<p>To make autocompletion persistent across shell sessions, you have a few options:</p> <ol> <li>System-wide Installation: Copy <code>autocomplete/bash_autocomplete</code> to <code>/etc/bash_completion.d/</code> and rename it to match your program's name (e.g., <code>/etc/bash_completion.d/myprogram</code>). This is common when distributing packages. Users may need to restart their shell or source the file manually (<code>source /etc/bash_completion.d/&lt;myprogram&gt;</code>) for the changes to take effect immediately.</li> </ol> <pre><code>$ sudo cp path/to/autocomplete/bash_autocomplete /etc/bash_completion.d/&lt;myprogram&gt;\n$ source /etc/bash_completion.d/&lt;myprogram&gt;\n</code></pre> <ol> <li>User Configuration: Instruct users to add the following lines to their shell configuration file (e.g., <code>~/.bashrc</code> or <code>~/.bash_profile</code>), ensuring they replace <code>&lt;myprogram&gt;</code> with the actual program name and <code>path/to/cli</code> with the correct path to the script:</li> </ol> <pre><code>$ PROG=&lt;myprogram&gt;\n$ source path/to/cli/autocomplete/bash_autocomplete\n</code></pre> <p>Keep in mind that if they are enabling auto-completion for more than one program, they will need to set <code>PROG</code> and source <code>autocomplete/bash_autocomplete</code> for each program, like so:</p> <pre><code>$ PROG=&lt;program1&gt;\n$ source path/to/cli/autocomplete/bash_autocomplete\n\n$ PROG=&lt;program2&gt;\n$ source path/to/cli/autocomplete/bash_autocomplete\n</code></pre>","boost":2},{"location":"examples/bash-completions/#customization","title":"Customization","text":"<p>The default shell completion flag (<code>--generate-bash-completion</code>) is defined as <code>cli.EnableBashCompletion</code>, and may be redefined if desired, e.g.:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        EnableBashCompletion: true,\n        Commands: []*cli.Command{\n            {\n                Name: \"wat\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","boost":2},{"location":"examples/bash-completions/#zsh-support","title":"ZSH Support","text":"<p>Auto-completion for ZSH is also supported using the <code>autocomplete/zsh_autocomplete</code> file included in this repo. One environment variable is used, <code>PROG</code>.  Set <code>PROG</code> to the program name as before, and then <code>source path/to/autocomplete/zsh_autocomplete</code>.  Adding the following lines to your ZSH configuration file (usually <code>.zshrc</code>) will allow the auto-completion to persist across new shells:</p> <pre><code>$ PROG=&lt;myprogram&gt;\n$ source path/to/autocomplete/zsh_autocomplete\n</code></pre>","boost":2},{"location":"examples/bash-completions/#zsh-default-auto-complete-example","title":"ZSH default auto-complete example","text":"","boost":2},{"location":"examples/bash-completions/#zsh-custom-auto-complete-example","title":"ZSH custom auto-complete example","text":"","boost":2},{"location":"examples/bash-completions/#powershell-support","title":"PowerShell Support","text":"<p>Auto-completion for PowerShell is also supported using the <code>autocomplete/powershell_autocomplete.ps1</code> file included in this repo.</p> <p>Rename the script to <code>&lt;my program&gt;.ps1</code> and move it anywhere in your file system.  The location of script does not matter, only the file name of the script has to match the your program's binary name.</p> <p>To activate it, enter:</p> <pre><code>&amp; path/to/autocomplete/&lt;my program&gt;.ps1\n</code></pre> <p>To persist across new shells, open the PowerShell profile (with <code>code $profile</code> or <code>notepad $profile</code>) and add the line:</p> <pre><code>&amp; path/to/autocomplete/&lt;my program&gt;.ps1\n</code></pre>","boost":2},{"location":"examples/combining-short-options/","title":"Combining Short Options","text":"<p>Normally, short options (like <code>-s</code>, <code>-o</code>, <code>-m</code>) are specified individually:</p> <pre><code>$ cmd -s -o -m \"Some message\"\n</code></pre> <p>If you want to allow users to combine multiple short boolean options (and optionally one non-boolean short option at the end), you can enable this behavior by setting <code>UseShortOptionHandling</code> to <code>true</code> on your <code>cli.App</code> or a specific <code>cli.Command</code>.</p> <p>Here's an example:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        UseShortOptionHandling: true,\n        Commands: []*cli.Command{\n            {\n                Name:  \"short\",\n                Usage: \"complete a task on the list\",\n                Flags: []cli.Flag{\n                    &amp;cli.BoolFlag{Name: \"serve\", Aliases: []string{\"s\"}},\n                    &amp;cli.BoolFlag{Name: \"option\", Aliases: []string{\"o\"}},\n                    &amp;cli.StringFlag{Name: \"message\", Aliases: []string{\"m\"}},\n                },\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"serve:\", cCtx.Bool(\"serve\"))\n                    fmt.Println(\"option:\", cCtx.Bool(\"option\"))\n                    fmt.Println(\"message:\", cCtx.String(\"message\"))\n                    return nil\n                },\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>If your program has any number of bool flags such as <code>serve</code> and <code>option</code>, and optionally one non-bool flag <code>message</code>, with the short options of <code>-s</code>, <code>-o</code>, and <code>-m</code> respectively, setting <code>UseShortOptionHandling</code> will also support the following syntax:</p> <pre><code>$ cmd -som \"Some message\"\n</code></pre> <p>Important: When <code>UseShortOptionHandling</code> is enabled, you cannot define flags that use a single dash followed by multiple characters (e.g., <code>-option</code>). This syntax becomes ambiguous with combined short options. Standard double-dash flags (e.g., <code>--option</code>) remain unaffected.</p>","boost":2},{"location":"examples/exit-codes/","title":"Exit Codes","text":"<p>By default, <code>App.Run</code> does not call <code>os.Exit</code>. If your application's <code>Action</code> (or subcommand actions) returns <code>nil</code>, the process exits with code <code>0</code>. To exit with a specific non-zero code, return an error that implements the <code>cli.ExitCoder</code> interface. The <code>cli.Exit</code> helper function is provided for convenience. If using <code>cli.MultiError</code>, the exit code will be determined by the first <code>cli.ExitCoder</code> found within the wrapped errors.</p> <p>Here's an example using <code>cli.Exit</code>:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.BoolFlag{\n                Name:  \"ginger-crouton\",\n                Usage: \"is it in the soup?\",\n            },\n        },\n        Action: func(ctx *cli.Context) error {\n            if !ctx.Bool(\"ginger-crouton\") {\n                return cli.Exit(\"Ginger croutons are not in the soup\", 86)\n            }\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","boost":2},{"location":"examples/flags/","title":"Flags","text":"<p>Flags provide ways for users to modify the behavior of your command-line application. Defining and accessing flags is straightforward.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:  \"lang\",\n                Value: \"english\",\n                Usage: \"language for the greeting\",\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            name := \"Nefertiti\"\n            if cCtx.NArg() &gt; 0 {\n                name = cCtx.Args().Get(0)\n            }\n            if cCtx.String(\"lang\") == \"spanish\" {\n                fmt.Println(\"Hola\", name)\n            } else {\n                fmt.Println(\"Hello\", name)\n            }\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>You can also bind a flag directly to a variable in your code using the <code>Destination</code> field. The flag's value will be automatically parsed and stored in the specified variable. If a default <code>Value</code> is also set for the flag, the <code>Destination</code> variable will be initialized to this default before command-line arguments are parsed.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    var language string\n\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:        \"lang\",\n                Value:       \"english\",\n                Usage:       \"language for the greeting\",\n                Destination: &amp;language,\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            name := \"someone\"\n            if cCtx.NArg() &gt; 0 {\n                name = cCtx.Args().Get(0)\n            }\n            if language == \"spanish\" {\n                fmt.Println(\"Hola\", name)\n            } else {\n                fmt.Println(\"Hello\", name)\n            }\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>See the Go Reference for a full list of available flag types.</p> <p>For boolean flags (<code>BoolFlag</code>), you can use the <code>Count</code> field to track how many times a flag is provided. This is useful for flags like <code>-v</code> for verbosity.</p> <p>Note: To support combining short boolean flags like <code>-vvv</code>, you must set <code>UseShortOptionHandling: true</code> on your <code>App</code> or <code>Command</code>. See the Combining Short Options example for details.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    var count int\n\n    app := &amp;cli.App{\n        UseShortOptionHandling: true,\n        Flags: []cli.Flag{\n            &amp;cli.BoolFlag{\n                Name:        \"foo\",\n                Usage:       \"foo greeting\",\n                Aliases:     []string{\"f\"},\n                Count: &amp;count,\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            fmt.Println(\"count\", count)\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","boost":2},{"location":"examples/flags/#placeholder-values","title":"Placeholder Values","text":"<p>You can indicate a placeholder for a flag's value directly within the <code>Usage</code> string. This helps clarify what kind of value the flag expects in the help output. Placeholders are denoted using backticks (<code>``</code>).</p> <p>For example this:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"config\",\n                Aliases: []string{\"c\"},\n                Usage:   \"Load configuration from `FILE`\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>--config FILE, -c FILE   Load configuration from FILE\n</code></pre> <p>Note that only the first placeholder is used. Subsequent back-quoted words will be left as-is.</p>","boost":2},{"location":"examples/flags/#alternate-names","title":"Alternate Names","text":"<p>Flags can have multiple names, often a longer descriptive name and a shorter alias. You can define aliases using the <code>Aliases</code> field, which accepts a slice of strings.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",        // Primary name\n                Aliases: []string{\"l\"}, // Alternate names\n                Value:   \"english\",\n                Usage:   \"language for the greeting\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>That flag can then be set with <code>--lang spanish</code> or <code>-l spanish</code>. Providing both forms (e.g., <code>--lang spanish -l spanish</code>) in the same command invocation will result in an error.</p>","boost":2},{"location":"examples/flags/#multiple-values-per-single-flag","title":"Multiple Values per Single Flag","text":"<p>Slice flags allow users to specify a flag multiple times, collecting all provided values into a slice. Available types include:</p> <ul> <li><code>Int64SliceFlag</code></li> <li><code>IntSliceFlag</code></li> <li><code>StringSliceFlag</code></li> </ul> <pre><code>package main\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"strings\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringSliceFlag{\n                Name:  \"greeting\",\n                Usage: \"Pass multiple greetings\",\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            fmt.Println(strings.Join(cCtx.StringSlice(\"greeting\"), `, `))\n            return nil\n        },\n    }\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>To pass multiple values, the user repeats the flag, e.g., <code>--greeting Hello --greeting Hola</code>.</p>","boost":2},{"location":"examples/flags/#grouping","title":"Grouping","text":"<p>You can associate a category for each flag to group them together in the help output, e.g:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.BoolFlag{\n                Name:     \"silent\",\n                Aliases:  []string{\"s\"},\n                Usage:    \"no messages\",\n                Category: \"Miscellaneous:\",\n            },\n            &amp;cli.BoolFlag{\n                Name:     \"perl-regexp\",\n                Aliases:  []string{\"P\"},\n                Usage:    \"PATTERNS are Perl regular expressions\",\n                Category: \"Pattern selection:\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>GLOBAL OPTIONS:\n   Miscellaneous:\n\n   --silent, -s  no messages (default: false)\n\n   Pattern selection:\n\n   --perl-regexp, -P  PATTERNS are Perl regular expressions (default: false)\n</code></pre>","boost":2},{"location":"examples/flags/#ordering","title":"Ordering","text":"<p>Flags for the application and commands are shown in the order they are defined. However, it's possible to sort them from outside this library by using <code>FlagsByName</code> or <code>CommandsByName</code> with <code>sort</code>.</p> <p>For example this:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"sort\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",\n                Aliases: []string{\"l\"},\n                Value:   \"english\",\n                Usage:   \"Language for the greeting\",\n            },\n            &amp;cli.StringFlag{\n                Name:    \"config\",\n                Aliases: []string{\"c\"},\n                Usage:   \"Load configuration from `FILE`\",\n            },\n        },\n        Commands: []*cli.Command{\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(*cli.Context) error {\n                    return nil\n                },\n            },\n            {\n                Name:    \"add\",\n                Aliases: []string{\"a\"},\n                Usage:   \"add a task to the list\",\n                Action: func(*cli.Context) error {\n                    return nil\n                },\n            },\n        },\n    }\n\n    sort.Sort(cli.FlagsByName(app.Flags))\n    sort.Sort(cli.CommandsByName(app.Commands))\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>--config FILE, -c FILE  Load configuration from FILE\n--lang value, -l value  Language for the greeting (default: \"english\")\n</code></pre>","boost":2},{"location":"examples/flags/#values-from-the-environment","title":"Values from the Environment","text":"<p>You can specify environment variables that can provide default values for flags using the <code>EnvVars</code> field (a slice of strings).</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",\n                Aliases: []string{\"l\"},\n                Value:   \"english\",\n                Usage:   \"language for the greeting\",\n                EnvVars: []string{\"APP_LANG\"},\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>If <code>EnvVars</code> contains multiple variable names, the library uses the value of the first environment variable found to be set.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",\n                Aliases: []string{\"l\"},\n                Value:   \"english\",\n                Usage:   \"language for the greeting\",\n                EnvVars: []string{\"LEGACY_COMPAT_LANG\", \"APP_LANG\", \"LANG\"},\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>If a flag's <code>Value</code> field is not explicitly set, but a corresponding environment variable from <code>EnvVars</code> is found, the environment variable's value will be used as the default and shown in the help text.</p>","boost":2},{"location":"examples/flags/#values-from-files","title":"Values from Files","text":"<p>Similarly to environment variables, you can specify a file path from which to read a flag's default value using the <code>FilePath</code> field.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:     \"password\",\n                Aliases:  []string{\"p\"},\n                Usage:    \"password for the mysql database\",\n                FilePath: \"/etc/mysql/password\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Note that default values sourced from environment variables (<code>EnvVars</code>) take precedence over those sourced from files (<code>FilePath</code>). See the full precedence order below.</p>","boost":2},{"location":"examples/flags/#required-flags","title":"Required Flags","text":"<p>You can enforce that a flag must be provided by the user by setting its <code>Required</code> field to <code>true</code>. If a required flag is missing, the application will print an error message and exit.</p> <p>Take for example this app that requires the <code>lang</code> flag:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:     \"lang\",\n                Value:    \"english\",\n                Usage:    \"language for the greeting\",\n                Required: true,\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            output := \"Hello\"\n            if cCtx.String(\"lang\") == \"spanish\" {\n                output = \"Hola\"\n            }\n            fmt.Println(output)\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>If the app is run without the <code>lang</code> flag, the user will see the following message</p> <pre><code>Required flag \"lang\" not set\n</code></pre>","boost":2},{"location":"examples/flags/#default-values-for-help-output","title":"Default Values for Help Output","text":"<p>In cases where a flag's default value (<code>Value</code> field) is dynamic or complex to represent (e.g., a randomly generated port), you can specify custom text to display as the default in the help output using the <code>DefaultText</code> field. This text is purely for display purposes and doesn't affect the actual default value used by the application.</p> <p>For example this:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.IntFlag{\n                Name:        \"port\",\n                Usage:       \"Use a randomized port\",\n                Value:       0,\n                DefaultText: \"random\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>--port value  Use a randomized port (default: random)\n</code></pre>","boost":2},{"location":"examples/flags/#precedence","title":"Precedence","text":"<p>The order of precedence for determining a flag's value is as follows (from highest to lowest):</p> <ol> <li>Value provided on the command line by the user.</li> <li>Value from the first set environment variable listed in <code>EnvVars</code>.</li> <li>Value read from the file specified in <code>FilePath</code>.</li> <li>Default value specified in the <code>Value</code> field of the flag definition.</li> </ol>","boost":2},{"location":"examples/flags/#flag-actions","title":"Flag Actions","text":"<p>You can attach an <code>Action</code> function directly to a flag definition. This function will be executed after the flag's value has been parsed from the command line, environment, or file. This is useful for performing validation or other logic specific to that flag. The action receives the <code>*cli.Context</code> and the parsed value of the flag.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"fmt\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.IntFlag{\n                Name:        \"port\",\n                Usage:       \"Use a randomized port\",\n                Value:       0,\n                DefaultText: \"random\",\n                Action: func(ctx *cli.Context, v int) error {\n                    if v &gt;= 65536 {\n                        return fmt.Errorf(\"Flag port value %v out of range[0-65535]\", v)\n                    }\n                    return nil\n                },\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>Flag port value 70000 out of range[0-65535]\n</code></pre>","boost":2},{"location":"examples/full-api-example/","title":"Full API Example","text":"<p>Notice: This is a contrived (functioning) example meant strictly for API demonstration purposes. Use of one's imagination is encouraged.</p> <pre><code>package main\n\nimport (\n    \"errors\"\n    \"flag\" \n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"time\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc init() {\n    cli.AppHelpTemplate += \"\\nCUSTOMIZED: you bet ur muffins\\n\"\n    cli.CommandHelpTemplate += \"\\nYMMV\\n\"\n    cli.SubcommandHelpTemplate += \"\\nor something\\n\"\n\n    cli.HelpFlag = &amp;cli.BoolFlag{Name: \"halp\"}\n    cli.VersionFlag = &amp;cli.BoolFlag{Name: \"print-version\", Aliases: []string{\"V\"}}\n\n    cli.HelpPrinter = func(w io.Writer, templ string, data interface{}) {\n        fmt.Fprintf(w, \"best of luck to you\\n\")\n    }\n    cli.VersionPrinter = func(cCtx *cli.Context) {\n        fmt.Fprintf(cCtx.App.Writer, \"version=%s\\n\", cCtx.App.Version)\n    }\n    cli.OsExiter = func(cCtx int) {\n        fmt.Fprintf(cli.ErrWriter, \"refusing to exit %d\\n\", cCtx)\n    }\n    cli.ErrWriter = io.Discard\n    cli.FlagStringer = func(fl cli.Flag) string {\n        return fmt.Sprintf(\"\\t\\t%s\", fl.Names()[0])\n    }\n}\n\ntype hexWriter struct{}\n\nfunc (w *hexWriter) Write(p []byte) (int, error) {\n    for _, b := range p {\n        fmt.Printf(\"%x\", b)\n    }\n    fmt.Printf(\"\\n\")\n\n    return len(p), nil\n} \n\ntype genericType struct {\n    s string\n}\n\nfunc (g *genericType) Set(value string) error {\n    g.s = value\n    return nil\n}\n\nfunc (g *genericType) String() string {\n    return g.s\n}\n\nfunc main() {\n    app := &amp;cli.App{\n        Name:     \"k\u0259n\u02c8tr\u012bv\",\n        Version:  \"v19.99.0\",\n        Compiled: time.Now(),\n        Authors: []*cli.Author{\n            &amp;cli.Author{\n                Name:  \"Example Human\",\n                Email: \"human@example.com\",\n            },\n        },\n        Copyright: \"(c) 1999 Serious Enterprise\",\n        HelpName:  \"contrive\",\n        Usage:     \"demonstrate available API\",\n        UsageText: \"contrive - demonstrating the available API\",\n        ArgsUsage: \"[args and such]\",\n        Commands: []*cli.Command{\n            &amp;cli.Command{\n                Name:        \"doo\",\n                Aliases:     []string{\"do\"},\n                Category:    \"motion\",\n                Usage:       \"do the doo\",\n                UsageText:   \"doo - does the dooing\",\n                Description: \"no really, there is a lot of dooing to be done\",\n                ArgsUsage:   \"[arrgh]\",\n                Flags: []cli.Flag{\n                    &amp;cli.BoolFlag{Name: \"forever\", Aliases: []string{\"forevvarr\"}},\n                },\n                Subcommands: []*cli.Command{\n                    &amp;cli.Command{\n                        Name:   \"wop\",\n                        Action: wopAction,\n                    },\n                },\n                SkipFlagParsing: false,\n                HideHelp:        false,\n                Hidden:          false,\n                HelpName:        \"doo!\",\n                BashComplete: func(cCtx *cli.Context) {\n                    fmt.Fprintf(cCtx.App.Writer, \"--better\\n\")\n                },\n                Before: func(cCtx *cli.Context) error {\n                    fmt.Fprintf(cCtx.App.Writer, \"brace for impact\\n\")\n                    return nil\n                },\n                After: func(cCtx *cli.Context) error {\n                    fmt.Fprintf(cCtx.App.Writer, \"did we lose anyone?\\n\")\n                    return nil\n                },\n                Action: func(cCtx *cli.Context) error {\n                    cCtx.Command.FullName()\n                    cCtx.Command.HasName(\"wop\")\n                    cCtx.Command.Names()\n                    cCtx.Command.VisibleFlags()\n                    fmt.Fprintf(cCtx.App.Writer, \"dodododododoodododddooooododododooo\\n\")\n                    if cCtx.Bool(\"forever\") {\n                        cCtx.Command.Run(cCtx)\n                    }\n                    return nil\n                },\n                OnUsageError: func(cCtx *cli.Context, err error, isSubcommand bool) error {\n                    fmt.Fprintf(cCtx.App.Writer, \"for shame\\n\")\n                    return err\n                },\n            },\n        },\n        Flags: []cli.Flag{\n            &amp;cli.BoolFlag{Name: \"fancy\"},\n            &amp;cli.BoolFlag{Value: true, Name: \"fancier\"},\n            &amp;cli.DurationFlag{Name: \"howlong\", Aliases: []string{\"H\"}, Value: time.Second * 3},\n            &amp;cli.Float64Flag{Name: \"howmuch\"},\n            &amp;cli.GenericFlag{Name: \"wat\", Value: &amp;genericType{}},\n            &amp;cli.Int64Flag{Name: \"longdistance\"},\n            &amp;cli.Int64SliceFlag{Name: \"intervals\"},\n            &amp;cli.IntFlag{Name: \"distance\"},\n            &amp;cli.IntSliceFlag{Name: \"times\"},\n            &amp;cli.StringFlag{Name: \"dance-move\", Aliases: []string{\"d\"}},\n            &amp;cli.StringSliceFlag{Name: \"names\", Aliases: []string{\"N\"}},\n            &amp;cli.UintFlag{Name: \"age\"},\n            &amp;cli.Uint64Flag{Name: \"bigage\"},\n        },\n        EnableBashCompletion: true,\n        HideHelp:             false,\n        HideVersion:          false,\n        BashComplete: func(cCtx *cli.Context) {\n            fmt.Fprintf(cCtx.App.Writer, \"lipstick\\nkiss\\nme\\nlipstick\\nringo\\n\")\n        },\n        Before: func(cCtx *cli.Context) error {\n            fmt.Fprintf(cCtx.App.Writer, \"HEEEERE GOES\\n\")\n            return nil\n        },\n        After: func(cCtx *cli.Context) error {\n            fmt.Fprintf(cCtx.App.Writer, \"Phew!\\n\")\n            return nil\n        },\n        CommandNotFound: func(cCtx *cli.Context, command string) {\n            fmt.Fprintf(cCtx.App.Writer, \"Thar be no %q here.\\n\", command)\n        },\n        OnUsageError: func(cCtx *cli.Context, err error, isSubcommand bool) error {\n            if isSubcommand {\n                return err\n            }\n\n            fmt.Fprintf(cCtx.App.Writer, \"WRONG: %#v\\n\", err)\n            return nil\n        },\n        Action: func(cCtx *cli.Context) error {\n            cli.DefaultAppComplete(cCtx)\n            cli.HandleExitCoder(errors.New(\"not an exit coder, though\"))\n            cli.ShowAppHelp(cCtx)\n            cli.ShowCommandCompletions(cCtx, \"nope\")\n            cli.ShowCommandHelp(cCtx, \"also-nope\")\n            cli.ShowCompletions(cCtx)\n            cli.ShowSubcommandHelp(cCtx)\n            cli.ShowVersion(cCtx)\n\n            fmt.Printf(\"%#v\\n\", cCtx.App.Command(\"doo\"))\n            if cCtx.Bool(\"infinite\") {\n                cCtx.App.Run([]string{\"app\", \"doo\", \"wop\"})\n            }\n\n            if cCtx.Bool(\"forevar\") {\n                cCtx.App.RunAsSubcommand(cCtx)\n            }\n            cCtx.App.Setup()\n            fmt.Printf(\"%#v\\n\", cCtx.App.VisibleCategories())\n            fmt.Printf(\"%#v\\n\", cCtx.App.VisibleCommands())\n            fmt.Printf(\"%#v\\n\", cCtx.App.VisibleFlags())\n\n            fmt.Printf(\"%#v\\n\", cCtx.Args().First())\n            if cCtx.Args().Len() &gt; 0 {\n                fmt.Printf(\"%#v\\n\", cCtx.Args().Get(1))\n            }\n            fmt.Printf(\"%#v\\n\", cCtx.Args().Present())\n            fmt.Printf(\"%#v\\n\", cCtx.Args().Tail())\n\n            set := flag.NewFlagSet(\"contrive\", 0)\n            nc := cli.NewContext(cCtx.App, set, cCtx)\n\n            fmt.Printf(\"%#v\\n\", nc.Args())\n            fmt.Printf(\"%#v\\n\", nc.Bool(\"nope\"))\n            fmt.Printf(\"%#v\\n\", !nc.Bool(\"nerp\"))\n            fmt.Printf(\"%#v\\n\", nc.Duration(\"howlong\"))\n            fmt.Printf(\"%#v\\n\", nc.Float64(\"hay\"))\n            fmt.Printf(\"%#v\\n\", nc.Generic(\"bloop\"))\n            fmt.Printf(\"%#v\\n\", nc.Int64(\"bonk\"))\n            fmt.Printf(\"%#v\\n\", nc.Int64Slice(\"burnks\"))\n            fmt.Printf(\"%#v\\n\", nc.Int(\"bips\"))\n            fmt.Printf(\"%#v\\n\", nc.IntSlice(\"blups\"))\n            fmt.Printf(\"%#v\\n\", nc.String(\"snurt\"))\n            fmt.Printf(\"%#v\\n\", nc.StringSlice(\"snurkles\"))\n            fmt.Printf(\"%#v\\n\", nc.Uint(\"flub\"))\n            fmt.Printf(\"%#v\\n\", nc.Uint64(\"florb\"))\n\n            fmt.Printf(\"%#v\\n\", nc.FlagNames())\n            fmt.Printf(\"%#v\\n\", nc.IsSet(\"wat\"))\n            fmt.Printf(\"%#v\\n\", nc.Set(\"wat\", \"nope\"))\n            fmt.Printf(\"%#v\\n\", nc.NArg())\n            fmt.Printf(\"%#v\\n\", nc.NumFlags())\n            fmt.Printf(\"%#v\\n\", nc.Lineage()[1])\n            nc.Set(\"wat\", \"also-nope\")\n\n            ec := cli.Exit(\"ohwell\", 86)\n            fmt.Fprintf(cCtx.App.Writer, \"%d\", ec.ExitCode())\n            fmt.Printf(\"made it!\\n\")\n            return ec\n        },\n        Metadata: map[string]interface{}{\n            \"layers\":          \"many\",\n            \"explicable\":      false,\n            \"whatever-values\": 19.99,\n        },\n    }\n\n    if os.Getenv(\"HEXY\") != \"\" {\n        app.Writer = &amp;hexWriter{}\n        app.ErrWriter = &amp;hexWriter{}\n    }\n\n    app.Run(os.Args)\n}\n\nfunc wopAction(cCtx *cli.Context) error {\n    fmt.Fprintf(cCtx.App.Writer, \":wave: over here, eh\\n\")\n    return nil\n}\n</code></pre>","boost":2},{"location":"examples/generated-help-text/","title":"Generated Help Text","text":"<p>The library automatically generates help text for your application, commands, and subcommands. By default, this help text is displayed when the user provides the <code>-h</code> or <code>--help</code> flag (defined by <code>cli.HelpFlag</code>). When this flag is detected, the help text is printed, and the application exits.</p>","boost":2},{"location":"examples/generated-help-text/#customization","title":"Customization","text":"<p>You have several ways to customize the generated help output:</p> <ol> <li>Modify Templates: The default Go text templates used for generation (<code>cli.AppHelpTemplate</code>, <code>cli.CommandHelpTemplate</code>, <code>cli.SubcommandHelpTemplate</code>) are exported variables. You can modify them directly, for example, by appending extra information or completely replacing them with your own template strings.</li> <li>Replace Help Printer: For complete control over rendering, you can replace the <code>cli.HelpPrinter</code> function. This function receives the output writer, the template string, and the data object (like <code>*cli.App</code> or <code>*cli.Command</code>) and is responsible for executing the template or generating help in any way you choose.</li> </ol> <p>Here are examples of these customization techniques:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    // EXAMPLE: Append to an existing template\n    cli.AppHelpTemplate = fmt.Sprintf(`%s\n\nWEBSITE: http://awesometown.example.com\n\nSUPPORT: support@awesometown.example.com\n\n`, cli.AppHelpTemplate)\n\n    // EXAMPLE: Override a template\n    cli.AppHelpTemplate = `NAME:\n   {{.Name}} - {{.Usage}}\nUSAGE:\n   {{.HelpName}} {{if .VisibleFlags}}[global options]{{end}}{{if .Commands}} command [command options]{{end}} {{if .ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}}\n   {{if len .Authors}}\nAUTHOR:\n   {{range .Authors}}{{ . }}{{end}}\n   {{end}}{{if .Commands}}\nCOMMANDS:\n{{range .Commands}}{{if not .HideHelp}}   {{join .Names \", \"}}{{ \"\\t\"}}{{.Usage}}{{ \"\\n\" }}{{end}}{{end}}{{end}}{{if .VisibleFlags}}\nGLOBAL OPTIONS:\n   {{range .VisibleFlags}}{{.}}\n   {{end}}{{end}}{{if .Copyright }}\nCOPYRIGHT:\n   {{.Copyright}}\n   {{end}}{{if .Version}}\nVERSION:\n   {{.Version}}\n   {{end}}\n`\n\n    // EXAMPLE: Replace the `HelpPrinter` func\n    cli.HelpPrinter = func(w io.Writer, templ string, data interface{}) {\n        fmt.Println(\"Ha HA.  I pwnd the help!!1\")\n    }\n\n    (&amp;cli.App{}).Run(os.Args)\n}\n</code></pre> <p>You can also change the flag used to trigger the help display (instead of the default <code>-h/--help</code>) by assigning a different <code>cli.Flag</code> implementation to the <code>cli.HelpFlag</code> variable:</p> <pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    cli.HelpFlag = &amp;cli.BoolFlag{\n        Name:    \"haaaaalp\",\n        Aliases: []string{\"halp\"},\n        Usage:   \"HALP\",\n        EnvVars: []string{\"SHOW_HALP\", \"HALPPLZ\"},\n    }\n\n    (&amp;cli.App{}).Run(os.Args)\n}\n</code></pre>","boost":2},{"location":"examples/greet/","title":"Greet","text":"<p>Let's build a simple \"greeter\" application to demonstrate the basic structure of a <code>cli</code> app. This example will create a command that prints a friendly greeting.</p> <p>Start by creating a directory named <code>greet</code>, and within it, add a file, <code>greet.go</code> with the following code in it:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Name:  \"greet\",\n        Usage: \"fight the loneliness!\",\n        Action: func(*cli.Context) error {\n            fmt.Println(\"Hello friend!\")\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Install our command to the <code>$GOPATH/bin</code> directory:</p> <pre><code>$ go install\n</code></pre> <p>Finally run our new command:</p> <pre><code>$ greet\nHello friend!\n</code></pre> <p>cli also generates neat help text:</p> <pre><code>$ greet help\nNAME:\n    greet - fight the loneliness!\n\nUSAGE:\n    greet [global options] command [command options] [arguments...]\n\nCOMMANDS:\n    help, h  Shows a list of commands or help for one command\n\nGLOBAL OPTIONS\n    --help, -h  show help (default: false)\n</code></pre>","boost":2},{"location":"examples/subcommands-categories/","title":"Subcommands Categories","text":"<p>When your application has numerous subcommands, organizing them into categories can significantly improve the clarity of the help output. You can assign a category to a command by setting its <code>Category</code> field. Commands with the same category will be grouped together in the help text.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Commands: []*cli.Command{\n            {\n                Name: \"noop\",\n            },\n            {\n                Name:     \"add\",\n                Category: \"template\",\n            },\n            {\n                Name:     \"remove\",\n                Category: \"template\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will include:</p> <pre><code>COMMANDS:\n  noop\n\n  template:\n    add\n    remove\n</code></pre>","boost":2},{"location":"examples/subcommands/","title":"Subcommands","text":"<p>You can structure your application with subcommands, similar to tools like <code>git</code> or <code>docker</code>. Define subcommands by assigning a slice of <code>*cli.Command</code> structs to the <code>Commands</code> field of your <code>cli.App</code> or another <code>cli.Command</code>.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Commands: []*cli.Command{\n            {\n                Name:    \"add\",\n                Aliases: []string{\"a\"},\n                Usage:   \"add a task to the list\",\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"added task: \", cCtx.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"completed task: \", cCtx.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"template\",\n                Aliases: []string{\"t\"},\n                Usage:   \"options for task templates\",\n                Subcommands: []*cli.Command{\n                    {\n                        Name:  \"add\",\n                        Usage: \"add a new template\",\n                        Action: func(cCtx *cli.Context) error {\n                            fmt.Println(\"new task template: \", cCtx.Args().First())\n                            return nil\n                        },\n                    },\n                    {\n                        Name:  \"remove\",\n                        Usage: \"remove an existing template\",\n                        Action: func(cCtx *cli.Context) error {\n                            fmt.Println(\"removed task template: \", cCtx.Args().First())\n                            return nil\n                        },\n                    },\n                },\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","boost":2},{"location":"examples/suggestions/","title":"Suggestions","text":"<p>You can enable suggestions for mistyped flags or commands by setting <code>Suggest: true</code> on your <code>cli.App</code>. When enabled, if a user enters an unrecognized flag or command, the application will suggest the closest match if one is found based on Levenshtein distance.</p>","boost":2},{"location":"examples/timestamp-flag/","title":"Timestamp Flag","text":"<p>The <code>TimestampFlag</code> allows users to provide date and time values as command-line arguments. You must specify the expected format using the <code>Layout</code> field. The layout string follows the rules of Go's <code>time.Parse</code> function (refer to the <code>time</code> package documentation for details on defining layouts).</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.TimestampFlag{Name: \"meeting\", Layout: \"2006-01-02T15:04:05\"},\n        },\n        Action: func(cCtx *cli.Context) error {\n            fmt.Printf(\"%s\", cCtx.Timestamp(\"meeting\").String())\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>In this example the flag could be used like this:</p> <pre><code>$ myapp --meeting 2019-08-12T15:04:05\n</code></pre> <p>If the specified <code>Layout</code> does not include timezone information, the parsed time will be in UTC by default. You can specify a different default timezone (like the system's local time) using the <code>Timezone</code> field:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"time\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.TimestampFlag{Name: \"meeting\", Layout: \"2006-01-02T15:04:05\", Timezone: time.Local},\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>(time.Local contains the system's local time zone.)</p> <p>Side note: quotes may be necessary around the date depending on your layout (if you have spaces for instance)</p>","boost":2},{"location":"examples/version-flag/","title":"Version Flag","text":"<p>Similar to the help flag, the library provides built-in support for a version flag. By default, <code>-v</code> or <code>--version</code> (defined by <code>cli.VersionFlag</code>) triggers the display of the application's version string (set in <code>App.Version</code>). The <code>cli.VersionPrinter</code> function handles the printing, and then the application exits.</p>","boost":2},{"location":"examples/version-flag/#customization","title":"Customization","text":"<p>You can customize the version flag behavior:</p> <ol> <li>Change the Flag: Assign a different <code>cli.Flag</code> implementation to the <code>cli.VersionFlag</code> variable to change which flag(s) trigger the version display.</li> </ol> <pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    cli.VersionFlag = &amp;cli.BoolFlag{\n        Name:    \"print-version\",\n        Aliases: []string{\"V\"},\n        Usage:   \"print only the version\",\n    }\n\n    app := &amp;cli.App{\n        Name:    \"partay\",\n        Version: \"v19.99.0\",\n    }\n    app.Run(os.Args)\n}\n</code></pre> <ol> <li>Customize Output: Replace the <code>cli.VersionPrinter</code> function to control how the version information is formatted and printed. This is useful for including additional details like build revision numbers.</li> </ol> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nvar (\n    Revision = \"fafafaf\"\n)\n\nfunc main() {\n    cli.VersionPrinter = func(cCtx *cli.Context) {\n        fmt.Printf(\"version=%s revision=%s\\n\", cCtx.App.Version, Revision)\n    }\n\n    app := &amp;cli.App{\n        Name:    \"partay\",\n        Version: \"v19.99.0\",\n    }\n    app.Run(os.Args)\n}\n</code></pre>","boost":2}]}