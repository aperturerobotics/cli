{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to aperturerobotics/cli","text":"<p><code>aperturerobotics/cli</code> is a fork of the popular <code>urfave/cli</code> v2 package for building command line apps in Go.</p> <p>Key differences from <code>urfave/cli</code>:</p> <ol> <li>Slim and Reflection-Free:<ul> <li>Removed <code>reflect</code> usage for smaller binaries and better performance.</li> <li>Tinygo compatible.</li> <li>Removed documentation generators.</li> <li>Removed altsrc package to focus on CLI handling only.</li> </ul> </li> <li>Stability: Try to maintain backward compatibility as much as possible.</li> </ol> <p>Documentation:</p> <ul> <li>Getting Started</li> <li>Examples</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Here's a simple example to get you started:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Name:  \"greet\",\n        Usage: \"say hello\",\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"name\",\n                Value:   \"world\",\n                Usage:   \"who to greet\",\n                EnvVars: []string{\"GREET_NAME\"},\n            },\n        },\n        Action: func(ctx *cli.Context) error {\n            name := ctx.String(\"name\")\n            fmt.Printf(\"Hello %s!\\n\", name)\n            return nil\n        },\n        Subcommands: []*cli.Command{\n            {\n                Name:  \"add\",\n                Usage: \"add a task to the list\",\n                Action: func(ctx *cli.Context) error {\n                    fmt.Println(\"added task: \", ctx.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:  \"complete\",\n                Usage: \"complete a task on the list\",\n                Action: func(ctx *cli.Context) error {\n                    fmt.Println(\"completed task: \", ctx.Args().First())\n                    return nil\n                },\n            },\n        },\n    }\n\n    if err := cmd.Run(os.Args); err != nil {\n        fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n        os.Exit(1)\n    }\n}\n</code></pre> <p>Running this provides basic command functionality, including help text generation, flag parsing, environment variable handling, and subcommand routing. You can easily add more flags, subcommands, and complex actions. See the full getting started guide for more details.</p>"},{"location":"#supported-platforms","title":"Supported platforms","text":"<p>cli is tested against multiple versions of Go on Linux, and against the latest released version of Go on OS X and Windows. This project uses GitHub Actions for builds. To see our currently supported go versions and platforms, look at the github workflow configuration.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>One of the philosophies behind cli is that an API should be playful and full of discovery. So a cli app can be as little as one line of code in <code>main()</code>.</p> <pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    (&amp;cli.App{}).Run(os.Args)\n}\n</code></pre> <p>This app will run and show help text, but is not very useful. Let's give an action to execute and some help documentation:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Name:  \"boom\",\n        Usage: \"make an explosive entrance\",\n        Action: func(*cli.Context) error {\n            fmt.Println(\"boom! I say!\")\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Running this already gives you a ton of functionality, plus support for things like subcommands and flags, which are covered below.</p>","boost":2},{"location":"examples/arguments/","title":"Arguments","text":"<p>You can lookup arguments by calling the <code>Args</code> function on <code>cli.Context</code>, e.g.:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Action: func(cCtx *cli.Context) error {\n            fmt.Printf(\"Hello %q\", cCtx.Args().Get(0))\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","boost":2},{"location":"examples/bash-completions/","title":"Bash completions","text":"<p>You can enable completion commands by setting the <code>EnableBashCompletion</code> flag on the <code>App</code> object to <code>true</code>.  By default, this setting will allow auto-completion for an app's subcommands, but you can write your own completion methods for the App or its subcommands as well.</p>","boost":2},{"location":"examples/bash-completions/#default-auto-completion","title":"Default auto-completion","text":"<p><pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        EnableBashCompletion: true,\n        Commands: []*cli.Command{\n            {\n                Name:    \"add\",\n                Aliases: []string{\"a\"},\n                Usage:   \"add a task to the list\",\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"added task: \", cCtx.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"completed task: \", cCtx.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"template\",\n                Aliases: []string{\"t\"},\n                Usage:   \"options for task templates\",\n                Subcommands: []*cli.Command{\n                    {\n                        Name:  \"add\",\n                        Usage: \"add a new template\",\n                        Action: func(cCtx *cli.Context) error {\n                            fmt.Println(\"new task template: \", cCtx.Args().First())\n                            return nil\n                        },\n                    },\n                    {\n                        Name:  \"remove\",\n                        Usage: \"remove an existing template\",\n                        Action: func(cCtx *cli.Context) error {\n                            fmt.Println(\"removed task template: \", cCtx.Args().First())\n                            return nil\n                        },\n                    },\n                },\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> </p>","boost":2},{"location":"examples/bash-completions/#custom-auto-completion","title":"Custom auto-completion","text":"<p><pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    tasks := []string{\"cook\", \"clean\", \"laundry\", \"eat\", \"sleep\", \"code\"}\n\n    app := &amp;cli.App{\n        EnableBashCompletion: true,\n        Commands: []*cli.Command{\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"completed task: \", cCtx.Args().First())\n                    return nil\n                },\n                BashComplete: func(cCtx *cli.Context) {\n                    // This will complete if no args are passed\n                    if cCtx.NArg() &gt; 0 {\n                        return\n                    }\n                    for _, t := range tasks {\n                        fmt.Println(t)\n                    }\n                },\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> </p>","boost":2},{"location":"examples/bash-completions/#enabling","title":"Enabling","text":"<p>To enable auto-completion for the current shell session, a bash script, <code>autocomplete/bash_autocomplete</code> is included in this repo.</p> <p> The <code>bash-completion</code> package or equivalent that provides the <code>_get_comp_words_by_ref</code> function for the target platform must be installed and initialized for this completion script to work correctly.</p> <p>To use <code>autocomplete/bash_autocomplete</code> set an environment variable named <code>PROG</code> to the name of your program and then <code>source</code> the <code>autocomplete/bash_autocomplete</code> file.</p> <p>For example, if your cli program is called <code>myprogram</code>:</p> <pre><code>$ PROG=myprogram source path/to/cli/autocomplete/bash_autocomplete\n</code></pre> <p>Auto-completion is now enabled for the current shell, but will not persist into a new shell.</p>","boost":2},{"location":"examples/bash-completions/#distribution-and-persistent-autocompletion","title":"Distribution and Persistent Autocompletion","text":"<p>Copy <code>autocomplete/bash_autocomplete</code> into <code>/etc/bash_completion.d/</code> and rename it to the name of the program you wish to add autocomplete support for (or automatically install it there if you are distributing a package). Don't forget to source the file or restart your shell to activate the auto-completion.</p> <pre><code>$ sudo cp path/to/autocomplete/bash_autocomplete /etc/bash_completion.d/&lt;myprogram&gt;\n$ source /etc/bash_completion.d/&lt;myprogram&gt;\n</code></pre> <p>Alternatively, you can just document that users should <code>source</code> the generic <code>autocomplete/bash_autocomplete</code> and set <code>$PROG</code> within their bash configuration file, adding these lines:</p> <pre><code>$ PROG=&lt;myprogram&gt;\n$ source path/to/cli/autocomplete/bash_autocomplete\n</code></pre> <p>Keep in mind that if they are enabling auto-completion for more than one program, they will need to set <code>PROG</code> and source <code>autocomplete/bash_autocomplete</code> for each program, like so:</p> <pre><code>$ PROG=&lt;program1&gt;\n$ source path/to/cli/autocomplete/bash_autocomplete\n\n$ PROG=&lt;program2&gt;\n$ source path/to/cli/autocomplete/bash_autocomplete\n</code></pre>","boost":2},{"location":"examples/bash-completions/#customization","title":"Customization","text":"<p>The default shell completion flag (<code>--generate-bash-completion</code>) is defined as <code>cli.EnableBashCompletion</code>, and may be redefined if desired, e.g.:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        EnableBashCompletion: true,\n        Commands: []*cli.Command{\n            {\n                Name: \"wat\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","boost":2},{"location":"examples/bash-completions/#zsh-support","title":"ZSH Support","text":"<p>Auto-completion for ZSH is also supported using the <code>autocomplete/zsh_autocomplete</code> file included in this repo. One environment variable is used, <code>PROG</code>.  Set <code>PROG</code> to the program name as before, and then <code>source path/to/autocomplete/zsh_autocomplete</code>.  Adding the following lines to your ZSH configuration file (usually <code>.zshrc</code>) will allow the auto-completion to persist across new shells:</p> <pre><code>$ PROG=&lt;myprogram&gt;\n$ source path/to/autocomplete/zsh_autocomplete\n</code></pre>","boost":2},{"location":"examples/bash-completions/#zsh-default-auto-complete-example","title":"ZSH default auto-complete example","text":"","boost":2},{"location":"examples/bash-completions/#zsh-custom-auto-complete-example","title":"ZSH custom auto-complete example","text":"","boost":2},{"location":"examples/bash-completions/#powershell-support","title":"PowerShell Support","text":"<p>Auto-completion for PowerShell is also supported using the <code>autocomplete/powershell_autocomplete.ps1</code> file included in this repo.</p> <p>Rename the script to <code>&lt;my program&gt;.ps1</code> and move it anywhere in your file system.  The location of script does not matter, only the file name of the script has to match the your program's binary name.</p> <p>To activate it, enter:</p> <pre><code>&amp; path/to/autocomplete/&lt;my program&gt;.ps1\n</code></pre> <p>To persist across new shells, open the PowerShell profile (with <code>code $profile</code> or <code>notepad $profile</code>) and add the line:</p> <pre><code>&amp; path/to/autocomplete/&lt;my program&gt;.ps1\n</code></pre>","boost":2},{"location":"examples/combining-short-options/","title":"Combining short options","text":"<p>Traditional use of options using their shortnames look like this:</p> <pre><code>$ cmd -s -o -m \"Some message\"\n</code></pre> <p>Suppose you want users to be able to combine options with their shortnames. This can be done using the <code>UseShortOptionHandling</code> bool in your app configuration, or for individual commands by attaching it to the command configuration. For example:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        UseShortOptionHandling: true,\n        Commands: []*cli.Command{\n            {\n                Name:  \"short\",\n                Usage: \"complete a task on the list\",\n                Flags: []cli.Flag{\n                    &amp;cli.BoolFlag{Name: \"serve\", Aliases: []string{\"s\"}},\n                    &amp;cli.BoolFlag{Name: \"option\", Aliases: []string{\"o\"}},\n                    &amp;cli.StringFlag{Name: \"message\", Aliases: []string{\"m\"}},\n                },\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"serve:\", cCtx.Bool(\"serve\"))\n                    fmt.Println(\"option:\", cCtx.Bool(\"option\"))\n                    fmt.Println(\"message:\", cCtx.String(\"message\"))\n                    return nil\n                },\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>If your program has any number of bool flags such as <code>serve</code> and <code>option</code>, and optionally one non-bool flag <code>message</code>, with the short options of <code>-s</code>, <code>-o</code>, and <code>-m</code> respectively, setting <code>UseShortOptionHandling</code> will also support the following syntax:</p> <pre><code>$ cmd -som \"Some message\"\n</code></pre> <p>If you enable <code>UseShortOptionHandling</code>, then you must not use any flags that have a single leading <code>-</code> or this will result in failures. For example, <code>-option</code> can no longer be used. Flags with two leading dashes (such as <code>--options</code>) are still valid.</p>","boost":2},{"location":"examples/exit-codes/","title":"Exit codes","text":"<p>Calling <code>App.Run</code> will not automatically call <code>os.Exit</code>, which means that by default the exit code will \"fall through\" to being <code>0</code>.  An explicit exit code may be set by returning a non-nil error that fulfills <code>cli.ExitCoder</code>, or a <code>cli.MultiError</code> that includes an error that fulfills <code>cli.ExitCoder</code>, e.g.:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.BoolFlag{\n                Name:  \"ginger-crouton\",\n                Usage: \"is it in the soup?\",\n            },\n        },\n        Action: func(ctx *cli.Context) error {\n            if !ctx.Bool(\"ginger-crouton\") {\n                return cli.Exit(\"Ginger croutons are not in the soup\", 86)\n            }\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","boost":2},{"location":"examples/flags/","title":"Flags","text":"<p>Setting and querying flags is simple.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:  \"lang\",\n                Value: \"english\",\n                Usage: \"language for the greeting\",\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            name := \"Nefertiti\"\n            if cCtx.NArg() &gt; 0 {\n                name = cCtx.Args().Get(0)\n            }\n            if cCtx.String(\"lang\") == \"spanish\" {\n                fmt.Println(\"Hola\", name)\n            } else {\n                fmt.Println(\"Hello\", name)\n            }\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>You can also set a destination variable for a flag, to which the content will be scanned. Note that if the <code>Value</code> is set for the flag, it will be shown as default, and destination will be set to this value before parsing flag on the command line.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    var language string\n\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:        \"lang\",\n                Value:       \"english\",\n                Usage:       \"language for the greeting\",\n                Destination: &amp;language,\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            name := \"someone\"\n            if cCtx.NArg() &gt; 0 {\n                name = cCtx.Args().Get(0)\n            }\n            if language == \"spanish\" {\n                fmt.Println(\"Hola\", name)\n            } else {\n                fmt.Println(\"Hello\", name)\n            }\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>See full list of flags at https://pkg.go.dev/github.com/aperturerobotics/cli</p> <p>For bool flags you can specify the flag multiple times to get a count(e.g -v -v -v or -vvv)</p> <p>If you want to support the <code>-vvv</code> flag, you need to set <code>App.UseShortOptionHandling</code>.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    var count int\n\n    app := &amp;cli.App{\n        UseShortOptionHandling: true,\n        Flags: []cli.Flag{\n            &amp;cli.BoolFlag{\n                Name:        \"foo\",\n                Usage:       \"foo greeting\",\n                Aliases:     []string{\"f\"},\n                Count: &amp;count,\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            fmt.Println(\"count\", count)\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","boost":2},{"location":"examples/flags/#placeholder-values","title":"Placeholder Values","text":"<p>Sometimes it's useful to specify a flag's value within the usage string itself. Such placeholders are indicated with back quotes.</p> <p>For example this:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"config\",\n                Aliases: []string{\"c\"},\n                Usage:   \"Load configuration from `FILE`\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>--config FILE, -c FILE   Load configuration from FILE\n</code></pre> <p>Note that only the first placeholder is used. Subsequent back-quoted words will be left as-is.</p>","boost":2},{"location":"examples/flags/#alternate-names","title":"Alternate Names","text":"<p>You can set alternate (or short) names for flags by providing a comma-delimited list for the <code>Name</code>. e.g.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",\n                Aliases: []string{\"l\"},\n                Value:   \"english\",\n                Usage:   \"language for the greeting\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>That flag can then be set with <code>--lang spanish</code> or <code>-l spanish</code>. Note that giving two different forms of the same flag in the same command invocation is an error.</p>","boost":2},{"location":"examples/flags/#multiple-values-per-single-flag","title":"Multiple Values per Single Flag","text":"<p>Using a slice flag allows you to pass multiple values for a single flag; the values will be provided as a slice:</p> <ul> <li><code>Int64SliceFlag</code></li> <li><code>IntSliceFlag</code></li> <li><code>StringSliceFlag</code></li> </ul> <pre><code>package main\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"strings\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringSliceFlag{\n                Name:  \"greeting\",\n                Usage: \"Pass multiple greetings\",\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            fmt.Println(strings.Join(cCtx.StringSlice(\"greeting\"), `, `))\n            return nil\n        },\n    }\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Multiple values need to be passed as separate, repeating flags, e.g. <code>--greeting Hello --greeting Hola</code>.</p>","boost":2},{"location":"examples/flags/#grouping","title":"Grouping","text":"<p>You can associate a category for each flag to group them together in the help output, e.g:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.BoolFlag{\n                Name:     \"silent\",\n                Aliases:  []string{\"s\"},\n                Usage:    \"no messages\",\n                Category: \"Miscellaneous:\",\n            },\n            &amp;cli.BoolFlag{\n                Name:     \"perl-regexp\",\n                Aliases:  []string{\"P\"},\n                Usage:    \"PATTERNS are Perl regular expressions\",\n                Category: \"Pattern selection:\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>GLOBAL OPTIONS:\n   Miscellaneous:\n\n   --silent, -s  no messages (default: false)\n\n   Pattern selection:\n\n   --perl-regexp, -P  PATTERNS are Perl regular expressions (default: false)\n</code></pre>","boost":2},{"location":"examples/flags/#ordering","title":"Ordering","text":"<p>Flags for the application and commands are shown in the order they are defined. However, it's possible to sort them from outside this library by using <code>FlagsByName</code> or <code>CommandsByName</code> with <code>sort</code>.</p> <p>For example this:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"sort\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",\n                Aliases: []string{\"l\"},\n                Value:   \"english\",\n                Usage:   \"Language for the greeting\",\n            },\n            &amp;cli.StringFlag{\n                Name:    \"config\",\n                Aliases: []string{\"c\"},\n                Usage:   \"Load configuration from `FILE`\",\n            },\n        },\n        Commands: []*cli.Command{\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(*cli.Context) error {\n                    return nil\n                },\n            },\n            {\n                Name:    \"add\",\n                Aliases: []string{\"a\"},\n                Usage:   \"add a task to the list\",\n                Action: func(*cli.Context) error {\n                    return nil\n                },\n            },\n        },\n    }\n\n    sort.Sort(cli.FlagsByName(app.Flags))\n    sort.Sort(cli.CommandsByName(app.Commands))\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>--config FILE, -c FILE  Load configuration from FILE\n--lang value, -l value  Language for the greeting (default: \"english\")\n</code></pre>","boost":2},{"location":"examples/flags/#values-from-the-environment","title":"Values from the Environment","text":"<p>You can also have the default value set from the environment via <code>EnvVars</code>.  e.g.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",\n                Aliases: []string{\"l\"},\n                Value:   \"english\",\n                Usage:   \"language for the greeting\",\n                EnvVars: []string{\"APP_LANG\"},\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>If <code>EnvVars</code> contains more than one string, the first environment variable that resolves is used.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",\n                Aliases: []string{\"l\"},\n                Value:   \"english\",\n                Usage:   \"language for the greeting\",\n                EnvVars: []string{\"LEGACY_COMPAT_LANG\", \"APP_LANG\", \"LANG\"},\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>When <code>Value</code> is not set for the flag, but a matching environment variable is found, the value from the environment will be used in the generated docs as the default value.</p>","boost":2},{"location":"examples/flags/#values-from-files","title":"Values from files","text":"<p>You can also have the default value set from file via <code>FilePath</code>.  e.g.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:     \"password\",\n                Aliases:  []string{\"p\"},\n                Usage:    \"password for the mysql database\",\n                FilePath: \"/etc/mysql/password\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Note that default values set from the environment (e.g. <code>EnvVar</code>) take precedence over default values set from file (e.g. <code>FilePath</code>).</p>","boost":2},{"location":"examples/flags/#required-flags","title":"Required Flags","text":"<p>You can make a flag required by setting the <code>Required</code> field to <code>true</code>. If a user does not provide a required flag, they will be shown an error message.</p> <p>Take for example this app that requires the <code>lang</code> flag:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:     \"lang\",\n                Value:    \"english\",\n                Usage:    \"language for the greeting\",\n                Required: true,\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            output := \"Hello\"\n            if cCtx.String(\"lang\") == \"spanish\" {\n                output = \"Hola\"\n            }\n            fmt.Println(output)\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>If the app is run without the <code>lang</code> flag, the user will see the following message</p> <pre><code>Required flag \"lang\" not set\n</code></pre>","boost":2},{"location":"examples/flags/#default-values-for-help-output","title":"Default Values for help output","text":"<p>Sometimes it's useful to specify a flag's default help-text value within the flag declaration. This can be useful if the default value for a flag is a computed value. The default value can be set via the <code>DefaultText</code> struct field.</p> <p>For example this:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.IntFlag{\n                Name:        \"port\",\n                Usage:       \"Use a randomized port\",\n                Value:       0,\n                DefaultText: \"random\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>--port value  Use a randomized port (default: random)\n</code></pre>","boost":2},{"location":"examples/flags/#precedence","title":"Precedence","text":"<p>The precedence for flag value sources is as follows (highest to lowest):</p> <ol> <li>Command line flag value from user</li> <li>Environment variable (if specified)</li> <li>Configuration file (if specified)</li> <li>Default defined on the flag</li> </ol>","boost":2},{"location":"examples/flags/#flag-actions","title":"Flag Actions","text":"<p>Handlers can be registered per flag which are triggered after a flag has been processed.  This can be used for a variety of purposes, one of which is flag validation</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"fmt\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.IntFlag{\n                Name:        \"port\",\n                Usage:       \"Use a randomized port\",\n                Value:       0,\n                DefaultText: \"random\",\n                Action: func(ctx *cli.Context, v int) error {\n                    if v &gt;= 65536 {\n                        return fmt.Errorf(\"Flag port value %v out of range[0-65535]\", v)\n                    }\n                    return nil\n                },\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>Flag port value 70000 out of range[0-65535]\n</code></pre>","boost":2},{"location":"examples/full-api-example/","title":"Full api example","text":"<p>Notice: This is a contrived (functioning) example meant strictly for API demonstration purposes. Use of one's imagination is encouraged.</p> <pre><code>package main\n\nimport (\n    \"errors\"\n    \"flag\" \n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"time\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc init() {\n    cli.AppHelpTemplate += \"\\nCUSTOMIZED: you bet ur muffins\\n\"\n    cli.CommandHelpTemplate += \"\\nYMMV\\n\"\n    cli.SubcommandHelpTemplate += \"\\nor something\\n\"\n\n    cli.HelpFlag = &amp;cli.BoolFlag{Name: \"halp\"}\n    cli.VersionFlag = &amp;cli.BoolFlag{Name: \"print-version\", Aliases: []string{\"V\"}}\n\n    cli.HelpPrinter = func(w io.Writer, templ string, data interface{}) {\n        fmt.Fprintf(w, \"best of luck to you\\n\")\n    }\n    cli.VersionPrinter = func(cCtx *cli.Context) {\n        fmt.Fprintf(cCtx.App.Writer, \"version=%s\\n\", cCtx.App.Version)\n    }\n    cli.OsExiter = func(cCtx int) {\n        fmt.Fprintf(cli.ErrWriter, \"refusing to exit %d\\n\", cCtx)\n    }\n    cli.ErrWriter = io.Discard\n    cli.FlagStringer = func(fl cli.Flag) string {\n        return fmt.Sprintf(\"\\t\\t%s\", fl.Names()[0])\n    }\n}\n\ntype hexWriter struct{}\n\nfunc (w *hexWriter) Write(p []byte) (int, error) {\n    for _, b := range p {\n        fmt.Printf(\"%x\", b)\n    }\n    fmt.Printf(\"\\n\")\n\n    return len(p), nil\n} \n\ntype genericType struct {\n    s string\n}\n\nfunc (g *genericType) Set(value string) error {\n    g.s = value\n    return nil\n}\n\nfunc (g *genericType) String() string {\n    return g.s\n}\n\nfunc main() {\n    app := &amp;cli.App{\n        Name:     \"k\u0259n\u02c8tr\u012bv\",\n        Version:  \"v19.99.0\",\n        Compiled: time.Now(),\n        Authors: []*cli.Author{\n            &amp;cli.Author{\n                Name:  \"Example Human\",\n                Email: \"human@example.com\",\n            },\n        },\n        Copyright: \"(c) 1999 Serious Enterprise\",\n        HelpName:  \"contrive\",\n        Usage:     \"demonstrate available API\",\n        UsageText: \"contrive - demonstrating the available API\",\n        ArgsUsage: \"[args and such]\",\n        Commands: []*cli.Command{\n            &amp;cli.Command{\n                Name:        \"doo\",\n                Aliases:     []string{\"do\"},\n                Category:    \"motion\",\n                Usage:       \"do the doo\",\n                UsageText:   \"doo - does the dooing\",\n                Description: \"no really, there is a lot of dooing to be done\",\n                ArgsUsage:   \"[arrgh]\",\n                Flags: []cli.Flag{\n                    &amp;cli.BoolFlag{Name: \"forever\", Aliases: []string{\"forevvarr\"}},\n                },\n                Subcommands: []*cli.Command{\n                    &amp;cli.Command{\n                        Name:   \"wop\",\n                        Action: wopAction,\n                    },\n                },\n                SkipFlagParsing: false,\n                HideHelp:        false,\n                Hidden:          false,\n                HelpName:        \"doo!\",\n                BashComplete: func(cCtx *cli.Context) {\n                    fmt.Fprintf(cCtx.App.Writer, \"--better\\n\")\n                },\n                Before: func(cCtx *cli.Context) error {\n                    fmt.Fprintf(cCtx.App.Writer, \"brace for impact\\n\")\n                    return nil\n                },\n                After: func(cCtx *cli.Context) error {\n                    fmt.Fprintf(cCtx.App.Writer, \"did we lose anyone?\\n\")\n                    return nil\n                },\n                Action: func(cCtx *cli.Context) error {\n                    cCtx.Command.FullName()\n                    cCtx.Command.HasName(\"wop\")\n                    cCtx.Command.Names()\n                    cCtx.Command.VisibleFlags()\n                    fmt.Fprintf(cCtx.App.Writer, \"dodododododoodododddooooododododooo\\n\")\n                    if cCtx.Bool(\"forever\") {\n                        cCtx.Command.Run(cCtx)\n                    }\n                    return nil\n                },\n                OnUsageError: func(cCtx *cli.Context, err error, isSubcommand bool) error {\n                    fmt.Fprintf(cCtx.App.Writer, \"for shame\\n\")\n                    return err\n                },\n            },\n        },\n        Flags: []cli.Flag{\n            &amp;cli.BoolFlag{Name: \"fancy\"},\n            &amp;cli.BoolFlag{Value: true, Name: \"fancier\"},\n            &amp;cli.DurationFlag{Name: \"howlong\", Aliases: []string{\"H\"}, Value: time.Second * 3},\n            &amp;cli.Float64Flag{Name: \"howmuch\"},\n            &amp;cli.GenericFlag{Name: \"wat\", Value: &amp;genericType{}},\n            &amp;cli.Int64Flag{Name: \"longdistance\"},\n            &amp;cli.Int64SliceFlag{Name: \"intervals\"},\n            &amp;cli.IntFlag{Name: \"distance\"},\n            &amp;cli.IntSliceFlag{Name: \"times\"},\n            &amp;cli.StringFlag{Name: \"dance-move\", Aliases: []string{\"d\"}},\n            &amp;cli.StringSliceFlag{Name: \"names\", Aliases: []string{\"N\"}},\n            &amp;cli.UintFlag{Name: \"age\"},\n            &amp;cli.Uint64Flag{Name: \"bigage\"},\n        },\n        EnableBashCompletion: true,\n        HideHelp:             false,\n        HideVersion:          false,\n        BashComplete: func(cCtx *cli.Context) {\n            fmt.Fprintf(cCtx.App.Writer, \"lipstick\\nkiss\\nme\\nlipstick\\nringo\\n\")\n        },\n        Before: func(cCtx *cli.Context) error {\n            fmt.Fprintf(cCtx.App.Writer, \"HEEEERE GOES\\n\")\n            return nil\n        },\n        After: func(cCtx *cli.Context) error {\n            fmt.Fprintf(cCtx.App.Writer, \"Phew!\\n\")\n            return nil\n        },\n        CommandNotFound: func(cCtx *cli.Context, command string) {\n            fmt.Fprintf(cCtx.App.Writer, \"Thar be no %q here.\\n\", command)\n        },\n        OnUsageError: func(cCtx *cli.Context, err error, isSubcommand bool) error {\n            if isSubcommand {\n                return err\n            }\n\n            fmt.Fprintf(cCtx.App.Writer, \"WRONG: %#v\\n\", err)\n            return nil\n        },\n        Action: func(cCtx *cli.Context) error {\n            cli.DefaultAppComplete(cCtx)\n            cli.HandleExitCoder(errors.New(\"not an exit coder, though\"))\n            cli.ShowAppHelp(cCtx)\n            cli.ShowCommandCompletions(cCtx, \"nope\")\n            cli.ShowCommandHelp(cCtx, \"also-nope\")\n            cli.ShowCompletions(cCtx)\n            cli.ShowSubcommandHelp(cCtx)\n            cli.ShowVersion(cCtx)\n\n            fmt.Printf(\"%#v\\n\", cCtx.App.Command(\"doo\"))\n            if cCtx.Bool(\"infinite\") {\n                cCtx.App.Run([]string{\"app\", \"doo\", \"wop\"})\n            }\n\n            if cCtx.Bool(\"forevar\") {\n                cCtx.App.RunAsSubcommand(cCtx)\n            }\n            cCtx.App.Setup()\n            fmt.Printf(\"%#v\\n\", cCtx.App.VisibleCategories())\n            fmt.Printf(\"%#v\\n\", cCtx.App.VisibleCommands())\n            fmt.Printf(\"%#v\\n\", cCtx.App.VisibleFlags())\n\n            fmt.Printf(\"%#v\\n\", cCtx.Args().First())\n            if cCtx.Args().Len() &gt; 0 {\n                fmt.Printf(\"%#v\\n\", cCtx.Args().Get(1))\n            }\n            fmt.Printf(\"%#v\\n\", cCtx.Args().Present())\n            fmt.Printf(\"%#v\\n\", cCtx.Args().Tail())\n\n            set := flag.NewFlagSet(\"contrive\", 0)\n            nc := cli.NewContext(cCtx.App, set, cCtx)\n\n            fmt.Printf(\"%#v\\n\", nc.Args())\n            fmt.Printf(\"%#v\\n\", nc.Bool(\"nope\"))\n            fmt.Printf(\"%#v\\n\", !nc.Bool(\"nerp\"))\n            fmt.Printf(\"%#v\\n\", nc.Duration(\"howlong\"))\n            fmt.Printf(\"%#v\\n\", nc.Float64(\"hay\"))\n            fmt.Printf(\"%#v\\n\", nc.Generic(\"bloop\"))\n            fmt.Printf(\"%#v\\n\", nc.Int64(\"bonk\"))\n            fmt.Printf(\"%#v\\n\", nc.Int64Slice(\"burnks\"))\n            fmt.Printf(\"%#v\\n\", nc.Int(\"bips\"))\n            fmt.Printf(\"%#v\\n\", nc.IntSlice(\"blups\"))\n            fmt.Printf(\"%#v\\n\", nc.String(\"snurt\"))\n            fmt.Printf(\"%#v\\n\", nc.StringSlice(\"snurkles\"))\n            fmt.Printf(\"%#v\\n\", nc.Uint(\"flub\"))\n            fmt.Printf(\"%#v\\n\", nc.Uint64(\"florb\"))\n\n            fmt.Printf(\"%#v\\n\", nc.FlagNames())\n            fmt.Printf(\"%#v\\n\", nc.IsSet(\"wat\"))\n            fmt.Printf(\"%#v\\n\", nc.Set(\"wat\", \"nope\"))\n            fmt.Printf(\"%#v\\n\", nc.NArg())\n            fmt.Printf(\"%#v\\n\", nc.NumFlags())\n            fmt.Printf(\"%#v\\n\", nc.Lineage()[1])\n            nc.Set(\"wat\", \"also-nope\")\n\n            ec := cli.Exit(\"ohwell\", 86)\n            fmt.Fprintf(cCtx.App.Writer, \"%d\", ec.ExitCode())\n            fmt.Printf(\"made it!\\n\")\n            return ec\n        },\n        Metadata: map[string]interface{}{\n            \"layers\":          \"many\",\n            \"explicable\":      false,\n            \"whatever-values\": 19.99,\n        },\n    }\n\n    if os.Getenv(\"HEXY\") != \"\" {\n        app.Writer = &amp;hexWriter{}\n        app.ErrWriter = &amp;hexWriter{}\n    }\n\n    app.Run(os.Args)\n}\n\nfunc wopAction(cCtx *cli.Context) error {\n    fmt.Fprintf(cCtx.App.Writer, \":wave: over here, eh\\n\")\n    return nil\n}\n</code></pre>","boost":2},{"location":"examples/generated-help-text/","title":"Generated help text","text":"<p>The default help flag (<code>-h/--help</code>) is defined as <code>cli.HelpFlag</code> and is checked by the cli internals in order to print generated help text for the app, command, or subcommand, and break execution.</p>","boost":2},{"location":"examples/generated-help-text/#customization","title":"Customization","text":"<p>All of the help text generation may be customized, and at multiple levels.  The templates are exposed as variables <code>AppHelpTemplate</code>, <code>CommandHelpTemplate</code>, and <code>SubcommandHelpTemplate</code> which may be reassigned or augmented, and full override is possible by assigning a compatible func to the <code>cli.HelpPrinter</code> variable, e.g.:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    // EXAMPLE: Append to an existing template\n    cli.AppHelpTemplate = fmt.Sprintf(`%s\n\nWEBSITE: http://awesometown.example.com\n\nSUPPORT: support@awesometown.example.com\n\n`, cli.AppHelpTemplate)\n\n    // EXAMPLE: Override a template\n    cli.AppHelpTemplate = `NAME:\n   {{.Name}} - {{.Usage}}\nUSAGE:\n   {{.HelpName}} {{if .VisibleFlags}}[global options]{{end}}{{if .Commands}} command [command options]{{end}} {{if .ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}}\n   {{if len .Authors}}\nAUTHOR:\n   {{range .Authors}}{{ . }}{{end}}\n   {{end}}{{if .Commands}}\nCOMMANDS:\n{{range .Commands}}{{if not .HideHelp}}   {{join .Names \", \"}}{{ \"\\t\"}}{{.Usage}}{{ \"\\n\" }}{{end}}{{end}}{{end}}{{if .VisibleFlags}}\nGLOBAL OPTIONS:\n   {{range .VisibleFlags}}{{.}}\n   {{end}}{{end}}{{if .Copyright }}\nCOPYRIGHT:\n   {{.Copyright}}\n   {{end}}{{if .Version}}\nVERSION:\n   {{.Version}}\n   {{end}}\n`\n\n    // EXAMPLE: Replace the `HelpPrinter` func\n    cli.HelpPrinter = func(w io.Writer, templ string, data interface{}) {\n        fmt.Println(\"Ha HA.  I pwnd the help!!1\")\n    }\n\n    (&amp;cli.App{}).Run(os.Args)\n}\n</code></pre> <p>The default flag may be customized to something other than <code>-h/--help</code> by setting <code>cli.HelpFlag</code>, e.g.:</p> <pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    cli.HelpFlag = &amp;cli.BoolFlag{\n        Name:    \"haaaaalp\",\n        Aliases: []string{\"halp\"},\n        Usage:   \"HALP\",\n        EnvVars: []string{\"SHOW_HALP\", \"HALPPLZ\"},\n    }\n\n    (&amp;cli.App{}).Run(os.Args)\n}\n</code></pre>","boost":2},{"location":"examples/greet/","title":"Greet","text":"<p>Being a programmer can be a lonely job. Thankfully by the power of automation that is not the case! Let's create a greeter app to fend off our demons of loneliness!</p> <p>Start by creating a directory named <code>greet</code>, and within it, add a file, <code>greet.go</code> with the following code in it:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Name:  \"greet\",\n        Usage: \"fight the loneliness!\",\n        Action: func(*cli.Context) error {\n            fmt.Println(\"Hello friend!\")\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Install our command to the <code>$GOPATH/bin</code> directory:</p> <pre><code>$ go install\n</code></pre> <p>Finally run our new command:</p> <pre><code>$ greet\nHello friend!\n</code></pre> <p>cli also generates neat help text:</p> <pre><code>$ greet help\nNAME:\n    greet - fight the loneliness!\n\nUSAGE:\n    greet [global options] command [command options] [arguments...]\n\nCOMMANDS:\n    help, h  Shows a list of commands or help for one command\n\nGLOBAL OPTIONS\n    --help, -h  show help (default: false)\n</code></pre>","boost":2},{"location":"examples/subcommands-categories/","title":"Subcommands categories","text":"<p>For additional organization in apps that have many subcommands, you can associate a category for each command to group them together in the help output, e.g.:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Commands: []*cli.Command{\n            {\n                Name: \"noop\",\n            },\n            {\n                Name:     \"add\",\n                Category: \"template\",\n            },\n            {\n                Name:     \"remove\",\n                Category: \"template\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will include:</p> <pre><code>COMMANDS:\n  noop\n\n  template:\n    add\n    remove\n</code></pre>","boost":2},{"location":"examples/subcommands/","title":"Subcommands","text":"<p>Subcommands can be defined for a more git-like command line app.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Commands: []*cli.Command{\n            {\n                Name:    \"add\",\n                Aliases: []string{\"a\"},\n                Usage:   \"add a task to the list\",\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"added task: \", cCtx.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"completed task: \", cCtx.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"template\",\n                Aliases: []string{\"t\"},\n                Usage:   \"options for task templates\",\n                Subcommands: []*cli.Command{\n                    {\n                        Name:  \"add\",\n                        Usage: \"add a new template\",\n                        Action: func(cCtx *cli.Context) error {\n                            fmt.Println(\"new task template: \", cCtx.Args().First())\n                            return nil\n                        },\n                    },\n                    {\n                        Name:  \"remove\",\n                        Usage: \"remove an existing template\",\n                        Action: func(cCtx *cli.Context) error {\n                            fmt.Println(\"removed task template: \", cCtx.Args().First())\n                            return nil\n                        },\n                    },\n                },\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","boost":2},{"location":"examples/suggestions/","title":"Suggestions","text":"<p>To enable flag and command suggestions, set <code>app.Suggest = true</code>. If the suggest feature is enabled, then the help output of the corresponding command will provide an appropriate suggestion for the provided flag or subcommand if available.</p>","boost":2},{"location":"examples/timestamp-flag/","title":"Timestamp flag","text":"<p>Using the timestamp flag is simple. Please refer to <code>time.Parse</code> to get possible formats.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.TimestampFlag{Name: \"meeting\", Layout: \"2006-01-02T15:04:05\"},\n        },\n        Action: func(cCtx *cli.Context) error {\n            fmt.Printf(\"%s\", cCtx.Timestamp(\"meeting\").String())\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>In this example the flag could be used like this:</p> <pre><code>$ myapp --meeting 2019-08-12T15:04:05\n</code></pre> <p>When the layout doesn't contain timezones, timestamp will render with UTC. To change behavior, a default timezone can be provided with flag definition:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"time\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.TimestampFlag{Name: \"meeting\", Layout: \"2006-01-02T15:04:05\", Timezone: time.Local},\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>(time.Local contains the system's local time zone.)</p> <p>Side note: quotes may be necessary around the date depending on your layout (if you have spaces for instance)</p>","boost":2},{"location":"examples/version-flag/","title":"Version flag","text":"<p>The default version flag (<code>-v/--version</code>) is defined as <code>cli.VersionFlag</code>, which is checked by the cli internals in order to print the <code>App.Version</code> via <code>cli.VersionPrinter</code> and break execution.</p>","boost":2},{"location":"examples/version-flag/#customization","title":"Customization","text":"<p>The default flag may be customized to something other than <code>-v/--version</code> by setting <code>cli.VersionFlag</code>, e.g.:</p> <pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nfunc main() {\n    cli.VersionFlag = &amp;cli.BoolFlag{\n        Name:    \"print-version\",\n        Aliases: []string{\"V\"},\n        Usage:   \"print only the version\",\n    }\n\n    app := &amp;cli.App{\n        Name:    \"partay\",\n        Version: \"v19.99.0\",\n    }\n    app.Run(os.Args)\n}\n</code></pre> <p>Alternatively, the version printer at <code>cli.VersionPrinter</code> may be overridden, e.g.:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n\n    \"github.com/aperturerobotics/cli\"\n)\n\nvar (\n    Revision = \"fafafaf\"\n)\n\nfunc main() {\n    cli.VersionPrinter = func(cCtx *cli.Context) {\n        fmt.Printf(\"version=%s revision=%s\\n\", cCtx.App.Version, Revision)\n    }\n\n    app := &amp;cli.App{\n        Name:    \"partay\",\n        Version: \"v19.99.0\",\n    }\n    app.Run(os.Args)\n}\n</code></pre>","boost":2}]}